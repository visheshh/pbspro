/*
 * Copyright (C) 1994-2018 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */
/**
 * @file    get_4byte.c
 *
 * @brief
 * 		get_4byte.c - contains functions related to get_sched_cmd sent by the Server.
 *
 * Functions included are:
 *	get_sched_cmd()
 *	get_sched_cmd_noblk()
 */

#include <pbs_config.h>   /* the master config generated by configure */
#include <stdlib.h>
#include <errno.h>
#include <arpa/inet.h>
#include "dis.h"
#include "sched_cmds.h"
#include "pbs_sched.h"
#include "log.h"
#include "misc.h"

#ifndef WIN32
#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>
#endif

#if defined(FD_SET_IN_SYS_SELECT_H)
#include <sys/select.h>
#endif

int
recv_int(int sock, int *num)
{
        int32_t ret;
        char *data = (char*)&ret;
        int left = sizeof(ret);
        int rc;
        do {
                rc = read(sock, data, left);
                if (rc == 0)
                	return -1;
                if (rc < 0) { /* instead of ret */
                    if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {
                	    continue;
                    }
                    else if (errno != EINTR) {
                        return -1;
                    }
                }
                else {
                    data += rc;
                    left -= rc;
                }
        } while (left > 0);

        *num = ntohl(ret);
        return 0;
}

int
recv_str(int sock, char *str, int len)
{
        int left = len;
        int rc;
        char *data = str;

        do {
                rc = read(sock, data, left);
                if (rc <= 0) { /* instead of ret */
                    if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {
                        continue;
                    }
                    else if (errno != EINTR) {
                        return -1;
                    }
                }
                else {
                	data += rc;
                	left -= rc;
                }
        } while (left > 0);

        *data = '\0';

        return 0;
}

/**
 *
 * @brief
 * 		Gets the Scheduler Command sent by the Server
 *
 * @param[in]	sock	-	socket endpoint to the server
 * @param[in]	val	-	pointer to the value of the scheduler command sent.
 * @param[in]	jid	-	if 'val' obtained is SCH_SCHEDULE_AJOB, then '*jid'
 *						holds the jobid of the job to be scheduled.
 * @return	int
 * @retval	0	: for EOF,
 * @retval	+1	: for success
 * @retval	-1	: for error.
 *
 * @note
 *		Callers need to free the value pointed to by 'jid' after returning
 *		from this call.
 */

int
get_sched_cmd(int sock, int *val, char **identifier)
{
	int	  id_len;

	if (recv_int(sock, val)) {
		return -1;
	}
	if ((*val == SCH_SCHEDULE_AJOB) || (*val == SCH_SVR_IDENTIFIER)) {
		if (recv_int(sock, &id_len)) {
			return -1;
		}
		*identifier = malloc(id_len + 1);
		if (*identifier == NULL)
			return -1;
		if (recv_str(sock, *identifier, id_len)) {
			return -1;
		}
	}

	return 1;
}

/**
 *
 * @brief
 * 		This is non-blocking version of get_sched_cmd().
 *
 * @param[in]	sock	-	communication endpoint to the server`
 * @param[in]	val	-	points to the value of the command sent by server.
 * @param[in]   jid	-	if *val is SCH_SCHEDULE_AJOB, then return jobid in
 *						*jid.
 * @return	int
 * @retval	0	for EOF,
 * @retval	+1	for success
 * @retval	-1	for error.
 *
 * @note
 *		Callers need to free the value pointed to by 'jid' after returning
 *		from this call.
 */

int
get_sched_cmd_noblk(int sock, int *val, char **jid)
{
	struct timeval timeout;
	fd_set		fdset;
	timeout.tv_usec = 0;
	timeout.tv_sec  = 0;
	extern int second_sd;

	/* As of now we have only one super high priority command like SCH_RESTART_SCHED_CYCLE
	 * which is only called from hooks. So it is not needed at this stage for POC. We have design in place
	 * to handle it and do it later.
	 */
	return 0;

	FD_ZERO(&fdset);
	FD_SET(second_sd, &fdset);
	if ((select(FD_SETSIZE, &fdset, NULL, NULL,
		&timeout) != -1)  && (FD_ISSET(second_sd, &fdset))) {
		return (get_sched_cmd(second_sd, val, jid));
	}
	return (0);
}
